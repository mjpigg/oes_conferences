'''
Functions for Evolving the Population toward best fitting schedule
DNA will be a dictionary of this structure:

DNA = {
        studentID: 'conf datetime'
        studentID: 'conf datetime'
        }

1 DNA strand represents a schedule which is on element of the population
'''
import random
import sqlite3
import datetime

def create_empty_schedule():
    '''
    creates and empty schedule of times
    :return:
    '''
    delta=datetime.timedelta(minutes=30)
    start=datetime.datetime(2018,2,28,7,30)
    n=1
    c=start
    a=1
    sch={}
    breaks=['9:30','12:0','12:30','14:30']
    while 1:
        the_time = "{}:{}".format(c.hour, c.minute)
        if c>datetime.datetime(2018,3,2,15):
            break
        if the_time in breaks and (c.weekday!=4 and the_time!='14:30'):
           # print('BREAK')
            c=c+delta
            continue
        if c>datetime.datetime(c.year,c.month,c.day,16,30):
            c=start+datetime.timedelta(hours=24*n)
            n+=1
            continue
        sch[str(c)]=[]
        a+=1
        c = c + delta
    return(sch)

def make_times(sort = True):
    conf_times = []
    the_times = create_empty_schedule()
    for x in range(5):
        for i in the_times:
            conf_times.append(i)
    if sort:
        return sorted(conf_times)

def get_ids():
    con = sqlite3.connect("conf.db")
    cur = con.cursor()
    cur.execute("SELECT studentID FROM confs;")
    rows = cur.fetchall()
    con.commit()
    con.close()
    ids = []
    for id in rows:
        ids.append(id[0])
    return ids

def create_dna(ids):
    sessions = make_times()
    dna = {}
    for id in ids:
        dna[id] = sessions.pop(random.randrange(len(sessions)))
    return dna

def conftime_to_preftime(conf_time):
    days = {2: 'Wed ', 3: 'Thu ', 4: 'Fri '}
    c = datetime.datetime.strptime(conf_time, "%Y-%m-%d %H:%M:%S")
    pref_time = days[c.weekday()]
    if c.hour < 11:
        pref_time += 'AM'
    elif c.hour < 14:
        pref_time += 'Mid'
    else:
        pref_time += 'PM'
    return pref_time

def get_prefs():
    '''
    This function will return a dictionary of the preferences for each student ID
    Data drawn from sqlite table generated by create_table and data originally from Survey Monkey
    :rtype: object
    :return:
    '''
    prefs={}
    con = sqlite3.connect("conf.db")
    cur = con.cursor()
    cur.execute("SELECT * from prefs;")
    rows = cur.fetchall()
    con.commit()
    con.close()
    for ID in rows:
        prefs[ID[0]]=(ID[1], ID[2], ID[3])
    return(prefs)


def fitness(dna):
    '''
    This function takes in a DNA and returns a normalized fitness score
    Things to consider for fitness:
        DONE student got pref1 +5
        DONE student got pref2 +3
        DONE student got pref3 +2
        4 or 5 sessions +1
        empty last conf +2
        all three grades per slot +5
        siblings are back to back + 10
        advisor conflict -1 for each one
        triple bookings -1 for each one
    :param dna :
    :return:
    '''
    score=0
    prefs = get_prefs()
    for key, value in dna.items():
        if key not in (prefs):
            score += 1 # no prefs, so plus 1
            continue
        pref=conftime_to_preftime(value)
        #print(type(pref), type(prefs[key][0]))
        if pref in prefs[key][0]: # got first pref
            score +=5
        elif pref in prefs[key][1]: # got second pref
            score +=3
        elif pref in prefs[key][1]: # got third pref
            score +=2
    return score

def create_population(n):
    # creates a population with n members, population is a list of lists with each list containing the fitness score
    # and the dna
    pop = []
    ids = get_ids()
    for i in range(n):
        dna = create_dna(ids)
        pop.append([fitness(dna), dna])
    return pop


def crossover(dna1,dna2):
    '''
    Takes in two "parent DNAs" and randomly crosses them
    by swapping conferences
    :param DNA_1:
    :param DNA_2:
    :return:
    '''
    ids = [x for x in dna1]
    new_dna = {}
    for id in ids:
        x = random.randint(1, 2)
        if x == 0:
            new_dna[id] = dna1[id]
        else:
            new_dna[id] = dna1[id]
    return new_dna

def mutate(dna, mutation_rate = .01):
    '''
    mutates the DNA
    swaps times with
    if session full, then swap with one ID already there, otherwise just move and now swap
    :param DNA:
    :return:
    '''
    # first create a list of he IDs sorted by time order
    tmp_list = []
    for key, value in dna.items():
        tmp_list.append((value,key))
    tmp_list.sort()
    swap_list=[]
    for n, x in enumerate(tmp_list[4:-4],4):
        if mutation_rate/2 > random.random():
            # moving later
            swap_list.append((tmp_list[n][1], tmp_list[n + random.randint(1,4)][1]))
        if 1-mutation_rate/2 < random.random():
            # moving earlier
            swap_list.append((tmp_list[n][1], tmp_list[n - random.randint(1, 4)][1]))
    for val in swap_list:
        dna[val[0]], dna[val[1]] = dna[val[1]], dna[val[0]]
    return dna




