'''
Functions for Evolving the Population toward best fitting schedule
DNA will be a dictionary of this structure:

DNA = {
        studentID: 'conf datetime'
        studentID: 'conf datetime'
        }

1 DNA strand represents a schedule which is on element of the population
'''
import random
import sqlite3
import datetime

def create_empty_schedule():
    '''
    creates and empty schedule of times
    :return:
    '''
    delta=datetime.timedelta(minutes=30)
    start=datetime.datetime(2018,2,28,7,30)
    n=1
    c=start
    a=1
    sch={}
    breaks=['9:30','12:0','12:30','14:30']
    while 1:
        the_time = "{}:{}".format(c.hour, c.minute)
        if c>datetime.datetime(2018,3,2,15):
            break
        if the_time in breaks and (c.weekday!=4 and the_time!='14:30'):
           # print('BREAK')
            c=c+delta
            continue
        if c>datetime.datetime(c.year,c.month,c.day,16,30):
            c=start+datetime.timedelta(hours=24*n)
            n+=1
            continue
        sch[str(c)]=[]
        a+=1
        c = c + delta
    return(sch)

def make_times(sort = True):
    conf_times = []
    the_times = create_empty_schedule()
    for x in range(5):
        for i in the_times:
            conf_times.append(i)
    if sort:
        return sorted(conf_times)

def get_ids():
    con = sqlite3.connect("conf.db")
    cur = con.cursor()
    cur.execute("SELECT studentID FROM confs;")
    rows = cur.fetchall()
    con.commit()
    con.close()
    ids = []
    for id in rows:
        ids.append(id[0])
    return ids

def create_dna(ids):
    sessions = make_times()
    dna = {}
    for id in ids:
        dna[id] = sessions.pop(random.randrange(len(sessions)))
    return dna

def conftime_to_preftime(conf_time):
    days = {2: 'Wed ', 3: 'Thu ', 4: 'Fri '}
    c = datetime.datetime.strptime(conf_time, "%Y-%m-%d %H:%M:%S")
    pref_time = days[c.weekday()]
    if c.hour < 11:
        pref_time += 'AM'
    elif c.hour < 14:
        pref_time += 'Mid'
    else:
        pref_time += 'PM'
    return pref_time

def get_prefs():
    '''
    This function will return a dictionary of the preferences for each student ID
    Data drawn from sqlite table generated by create_table and data originally from Survey Monkey
    :rtype: object
    :return:
    '''
    prefs={}
    con = sqlite3.connect("conf.db")
    cur = con.cursor()
    cur.execute("SELECT * from prefs;")
    rows = cur.fetchall()
    con.commit()
    con.close()
    for ID in rows:
        prefs[ID[0]]=(ID[1], ID[2], ID[3])
    return(prefs)


def fitness(dna):
    '''
    This function takes in a DNA and returns a normalized fitness score
    Things to consider for fitness:
        DONE student got pref1 +5
        DONE student got pref2 +3
        DONE student got pref3 +2
        4 or 5 sessions +1
        empty last conf +2
        all three grades per slot +5
        siblings are back to back + 10
        advisor conflict -1 for each one
        triple bookings -1 for each one
    :param dna :
    :return:
    '''
    score=0
    prefs = get_prefs()
    for key, value in dna.items():
        if key not in (prefs):
            score += 1 # no prefs, so plus 1
            continue
        pref=conftime_to_preftime(value)
        #print(type(pref), type(prefs[key][0]))
        if pref in prefs[key][0]: # got first pref
            score +=5
        elif pref in prefs[key][1]: # got second pref
            score +=3
        elif pref in prefs[key][1]: # got third pref
            score +=2
    return score

def create_population(n):
    # creates a population with n members, population is a list of lists with each list containing the fitness score
    # and the dna
    pop = []
    ids = get_ids()
    for i in range(n):
        dna = create_dna(ids)
        pop.append([fitness(dna), dna])
    return pop


def crossover(dna1,dna2):
    '''
    Takes in two "parent DNAs" and randomly crosses them
    by swapping conferences
    :param DNA_1:
    :param DNA_2:
    :return:
    '''
    ids = [x for x in dna1]
    new_dna = {}
    for id in ids:
        x = random.randint(1, 2)
        if x == 0:
            new_dna[id] = dna1[id]
        else:
            new_dna[id] = dna1[id]
    return new_dna

def mutate(dna, mutation_rate = .01):
    '''
    mutates the DNA
    swaps times with
    if session full, then swap with one ID already there, otherwise just move and now swap
    :param DNA:
    :return:
    '''
    # first create a list of he IDs sorted by time order
    tmp_list = []
    for key, value in dna.items():
        tmp_list.append((value,key))
    tmp_list.sort()
    swap_list=[]
    for n, x in enumerate(tmp_list[4:-4],4):
        if mutation_rate/2 > random.random():
            # moving later
            swap_list.append((tmp_list[n][1], tmp_list[n + random.randint(1,4)][1]))
        if 1-mutation_rate/2 < random.random():
            # moving earlier
            swap_list.append((tmp_list[n][1], tmp_list[n - random.randint(1, 4)][1]))
    for val in swap_list:
        dna[val[0]], dna[val[1]] = dna[val[1]], dna[val[0]]
    return dna

def pop_max_min(population):
    top = population[0][0]
    bottom = top
    max, min = 0, 0
    sum = 0
    for x, y in enumerate(population):
        sum += y[0]
        if y[0] > top:
            top = y[0]
            max = x
        if y[0] < bottom:
            bottom = y[0]
            min = x
    avg = sum / len(population)
    # top = highest fitness score
    # bottom = lowest fitness score
    # max = index of dna with highest fitness score
    return top, bottom, max, min, avg

def pick_parent(population):
    '''
    randomly pick a parent based on fitness score: higher the fitness score, more likely to be picked
    :param population:
    :return:
    '''
    pop_data = pop_max_min(population)
    min = pop_data[1]
    max = pop_data[0]
    x = 0
    while x < random.randint(min, max-1):
        tmp = random.choice(population)
        x = tmp[0]
    return tmp[1]


def make_new_generation(population, pop_size,mutation_rate):
    # pop_data = pop_max_min(population)
    # fittest = population[pop_data[2]]
    next_generation = []
    for i in range(pop_size):
        parent1 = pick_parent(population)
        parent2 = pick_parent(population)
        new_dna = crossover(parent1, parent2)
        new_dna = mutate(new_dna, mutation_rate)
        next_generation.append([fitness(new_dna),new_dna])
    return next_generation



