'''
Functions for Evolving the Population toward best fitting schedule
DNA will be a dictionary of this structure:

DNA = {
        studentID: 'conf datetime'
        studentID: 'conf datetime'
        }

1 DNA strand represents a schedule which is an element of the population
'''
import random
import sqlite3
import datetime, time
import pandas.io.sql as sql
import json
import numpy as np


the_random_seed = int(time.time())
#the_random_seed = 1520975814
#the_random_seed = 1520354947 #produces 926 at 73 gens
#the_random_seed = 1520447496 # 740 at 83, or 843 with gen combination
random.seed(the_random_seed)

def create_empty_schedule():
    '''
    creates an empty schedule of times
    :return:
    '''
    delta=datetime.timedelta(minutes=30)
    start=datetime.datetime(2018,2,28,7,30)
    n=1
    c=start
    a=1
    sch={}
    breaks = ['9:30','11:30','12:0','14:30']
    while 1:
        the_time = "{}:{}".format(c.hour, c.minute)
        if c>datetime.datetime(2018,3,2,15):
            break
        if the_time in breaks and c.weekday() != 4:
            c=c+delta
            continue
        if the_time in ['9:30','12:0','12:30'] and c.weekday() == 4:
            c=c+delta
            continue
        if c>datetime.datetime(c.year,c.month,c.day,16,30):
            c=start+datetime.timedelta(hours=24*n)
            n+=1
            continue
        sch[str(c)]=[]
        a += 1
        c = c + delta
    return(sch)


def make_times(sort = True):
    conf_times = []
    the_times = create_empty_schedule()
    for x in range(5):
        for i in the_times:
            conf_times.append(i)
    if sort:
        return sorted(conf_times)


def get_ids(): # returns the studentIDs
    con = sqlite3.connect("conf.db")
    cur = con.cursor()
    cur.execute("SELECT studentID FROM confs;")
    rows = cur.fetchall()
    con.commit()
    con.close()
    ids = []
    for id in rows:
        ids.append(id[0])
    return ids

def get_teacher_classes():
    con = sqlite3.connect("conf.db")
    cur = con.cursor()
    cur.execute("SELECT teacherlast, studentID from pcr WHERE dept NOT LIKE 'Activity' "
                "AND dept NOT LIKE 'perf%' GROUP BY teacherlast, studentID;")
    rows = cur.fetchall()
    con.commit()
    con.close()
    teacher_classes = {}
    for id in rows:
        teacher_classes[id[0]] = teacher_classes.get(id[0],[]) + [id[1]]
    return teacher_classes

def get_advisees():
    con = sqlite3.connect("conf.db")
    cur = con.cursor()
    cur.execute("SELECT advisor, studentID from pcr GROUP BY advisor, studentID;")
    rows = cur.fetchall()
    con.commit()
    con.close()
    advisees = {}
    for id in rows:
        advisees[id[0]] = advisees.get(id[0],[]) + [id[1]]
    return advisees

def get_student_grades():
    con = sqlite3.connect("conf.db")
    cur = con.cursor()
    cur.execute("SELECT studentID, grade from pcr GROUP BY studentID;")
    rows = cur.fetchall()
    con.commit()
    con.close()
    student_grades = {}
    for id in rows:
        student_grades[id[0]] = id[1]
    return student_grades


def create_dna(ids):
    sessions = make_times() # make this a class variable
    dna = {}
    for id in ids:
        dna[id] = sessions.pop(random.randrange(len(sessions)))
    return dna

def conftime_to_preftime(conf_time):
    days = {2: 'Wed ', 3: 'Thu ', 4: 'Fri '}
    c = datetime.datetime.strptime(conf_time, "%Y-%m-%d %H:%M:%S")
    pref_time = days[c.weekday()]
    if c.hour < 11:
        pref_time += 'AM'
    elif c.hour < 14:
        pref_time += 'Mid'
    else:
        pref_time += 'PM'
    return pref_time

def get_prefs():
    '''
    This function will return a dictionary of the preferences for each student ID
    Data drawn from sqlite table generated by create_table and data originally from Survey Monkey
    :rtype: object
    :return:
    '''
    prefs={}
    con = sqlite3.connect("conf.db")
    cur = con.cursor()
    cur.execute("SELECT * from prefs;")
    rows = cur.fetchall()
    con.commit()
    cur.close()
    con.close()
    for ID in rows:
        prefs[ID[0]]=(ID[1], ID[2], ID[3])
    return(prefs)

get_the_prefs_just_once = get_prefs()
teacher_classes = get_teacher_classes()
sample_dna = create_dna(get_ids())

def get_time_slots(dna):
    time_slots={}
    for id, slot in dna.items():
        time_slots[slot] = []
    for id, slot in dna.items():
        time_slots[slot].append(id)
    return time_slots

def advisee_doubles(dna):
    sched = create_empty_schedule()
    # print(sched)
    # print(sample_dna)
    advisees = get_advisees()
    # print(advisees)
    for id, time in dna.items():
        sched[time].append(id)
    swap_list = []
    for slot, ids1 in sched.items():
        for advisor, adviseeids in advisees.items():
            overlap = list(set(ids1).intersection(set(adviseeids)))
            if len(overlap) > 1:
                swap_list.append(overlap[0])

                #print(overlap[0],slot,advisor,overlap)
    return swap_list

the_sibs = [(20483, 20484), (20421, 20422), (22998, 21845), (21401, 21350), (21254, 22617), (21128, 21129),(21215, 21376)]

def sib_score(dna, sibs = the_sibs):
    # returns a tuple of (score, conflicts, non_adjacents)
    score, probs, adjacents = 0, 0, 0
    # find the time delta between the conferences
    for pair in sibs:
        time_diff = np.datetime64(dna[pair[0]]) - np.datetime64(dna[pair[1]])
        time_diff = abs(time_diff.item().total_seconds() / 60)
        if time_diff != 30:
            score -=50
            probs +=1
        else:
            adjacents +=1
    return score, probs, adjacents


def fitness(dna, prefs = get_the_prefs_just_once, t_classes = teacher_classes):
    '''
    This function takes in a DNA and returns a normalized fitness score
    Things to consider for fitness:
        DONE student got pref1 +10
        DONE student got pref2 +5
        DONE student got pref3 +3
        DONE student got NONE of their prefs -5
        DONE Teachers OverBooked -10
        DONE Advisor has more than one advisee per slot -50 per conflice
        not needed? 4 or 5 sessions +1
        not needed? empty last conf +2
        not needed? all three grades per slot +5
        DONE siblings not back to back -50
        DONE triple bookings -10 for each one
    :param dna :
    :return:
    '''
    score=0
    #prefs = get_prefs()
    for key, value in dna.items():
        if key not in (prefs):
            score += 1 # no prefs, so plus 1
            continue
        pref=conftime_to_preftime(value)
        #print(type(pref), type(prefs[key][0]))
        if pref in prefs[key][0]: # got first pref
            score +=10
        elif pref in prefs[key][1]: # got second pref
            score +=5
        elif pref in prefs[key][2]: # got third pref
            score += 3
        else: #got NONE of their choices
            score -= 5 #used to be -5

    # testing for more than double bookings
    for slot, ids1 in get_time_slots(dna).items():
        for teacher, ids2 in t_classes.items():
            bookings = len(set(ids1).intersection(ids2))
            if bookings > 2:
                # print(slot, teacher, len(set(ids1).intersection(ids2)))
                score -= 10

    # advisee doubles will be -50 for every one of them
    score -= 50*len(advisee_doubles(dna))

    # -50 for each sibling not back to back
    score += sib_score(dna)[0]
    return score


def create_population(n):
    # creates a population with n members, population is a list of lists with each list containing the fitness score
    # and the dna
    pop = []
    ids = get_ids()
    for i in range(n):
        dna = create_dna(ids)
        pop.append([fitness(dna), dna])
    return pop


def crossover(dna1,dna2):
    '''
    Takes in two "parent DNAs" and randomly crosses them
    by swapping conferences
    :param DNA_1:
    :param DNA_2:
    :return:
    '''
    ids = [x for x in dna1]
    new_dna = {}
    for id in ids:
        x = random.randint(1, 2)
        if x == 0:
            new_dna[id] = dna1[id]
        else:
            new_dna[id] = dna1[id]
    return new_dna


def sib_swaps(dna, sibs = the_sibs):
    swaps = []
    # moves sibs to be a conference before or after their sibling
    score, probs, adjacents = 0, 0, 0
    # find the time delta between the conferences
    for pair in sibs:
        time_diff = np.datetime64(dna[pair[0]]) - np.datetime64(dna[pair[1]])
        # print(dna[pair[0]], dna[pair[1]], abs(time_diff.item().total_seconds()/60))
        time_diff = abs(time_diff.item().total_seconds() / 60)
        if time_diff != 30: # if they are not adjacent
            # swap one of them... move the first id to a slot close to second id
            moveID = pair[0]
            move_to = dna[pair[1]]
            for id, slot in dna.items():
                time_diff = np.datetime64(move_to) - np.datetime64(slot)
                time_diff = abs(time_diff.item().total_seconds() / 60)
                if time_diff == 30:
                    swaps.append((moveID, id))
                    break

    return swaps


def mutate_no_prefs(dna, get_prefs = None):
    no_pref_ids=[]
    prefs = get_the_prefs_just_once
    for key, value in dna.items():
        if key not in get_the_prefs_just_once:
            continue
        pref = conftime_to_preftime(value)
        if get_prefs == None:
            if pref not in prefs[key][0]+prefs[key][1]+prefs[key][2]: # got none of their prefs
                no_pref_ids.append(key)
        else: # return just ids of those getting get_prefs preference
            if pref in prefs[key][get_prefs-1]: #
                no_pref_ids.append(key)

    return no_pref_ids

def swap_ids(dna,swap_list):
    #print(swap_list)
    for val in swap_list:
        #print(val)
        dna[val[0]], dna[val[1]] = dna[val[1]], dna[val[0]]
    return dna

def pref_swapper(dna, gen = 1):
    '''
    This is designed to find IDs with mirror image prefswho may benefit by swapping

    :param dna:
    :return:
    '''
    prefs = get_the_prefs_just_once
    pref1, pref2, pref3, no_pref = 0, 0, 0, 0
    have_want={}
    for key, value in dna.items():
        the_slot = conftime_to_preftime(value)
        #print(key,value,the_slot)
        if key not in get_the_prefs_just_once:
            #no preference at all
            have_want[the_slot+':'+'none'] = have_want.get(the_slot+':'+'none',[]) + [key]
            continue
        if the_slot not in prefs[key]:
            #print("Got {} but wanted {}".format(the_slot, prefs[key][2]))
            new_key = the_slot + ':' + prefs[key][random.randint(0,2)]
            have_want[new_key] = have_want.get(new_key, []) + [key]
        elif the_slot in prefs[key][1]: # got second pref
            #print("Got {} but wanted {}".format(the_slot, prefs[key][0]))
            new_key = the_slot+':'+prefs[key][0]
            have_want[new_key] = have_want.get(new_key, []) + [key]
        elif the_slot in prefs[key][2]: # got third pref
            # print("Got {} but wanted {}".format(the_slot, prefs[key][1]))
            new_key = the_slot + ':' + prefs[key][random.randint(0,1)]
            have_want[new_key] = have_want.get(new_key, []) + [key]
        '''
        if the_slot in prefs[key][0]: # got first pref
            #print("got first choice")
            #do nothing for first choice
            pass
        '''
    swaps = []
    swapped = []
    chance_of_swap = 1/((1+gen)**.5)
    # chance_of_swap = .1
    # print(chance_of_swap)
    for have, ids in have_want.items():
        tmp = have.split(':')
        want = tmp[1] + ':' + tmp[0]
        if want in have_want:
            if len(ids) > len(have_want[want]):
                shorter = len(have_want[want])
            else:
                shorter = len(ids)
            #print(shorter, have, ids, want, have_want[want])
            for i in range(shorter):
                if chance_of_swap > random.random():
                    first = random.choice(ids)
                    second = random.choice(have_want[want])
                    if first not in swapped and second not in swapped:
                        swaps.append((first, second))
                        swapped.append(first)
                        swapped.append(second)
        want = tmp[1] + ':none'
        if want in have_want:
            if len(ids) > len(have_want[want]):
                shorter = len(have_want[want])
            else:
                shorter = len(ids)
            #print(shorter, have, ids, want, have_want[want])
            for i in range(shorter):
                if chance_of_swap > random.random():
                    first = random.choice(ids)
                    second = random.choice(have_want[want])
                    if first not in swapped and second not in swapped:
                        swaps.append((first, second))
                        swapped.append(first)
                        swapped.append(second)
    #print(len(swaps), end = ' ')
    return swaps



#print(pref_swapper(sample_dna))



def mutate(dna, mutation_rate = .02, gen = 1):
    '''
    mutates the DNA
    swaps times with
    if session full, then swap with one ID already there, otherwise just move and now swap
    :param DNA:
    :return:
    '''
    # print(mutation_rate)
    # first create a list of he IDs sorted by time order
    tmp_list = []
    for key, value in dna.items(): # sorts the dna in time order
        tmp_list.append((value,key))
    tmp_list.sort()

    swap_list=[]
    for n, x in enumerate(tmp_list[4:-4],4):
        if mutation_rate/2 > random.random():
            # moving later
            swap_list.append((tmp_list[n][1], tmp_list[n + random.randint(1,4)][1]))
        if 1-mutation_rate/2 < random.random():
            # moving earlier
            swap_list.append((tmp_list[n][1], tmp_list[n - random.randint(1, 4)][1]))

    # do the mutation swap
    dna = swap_ids(dna, swap_list)
    swap_list = []


    # more for the swap list: swapping between ids with no preferences yet met
    no_pref_ids = mutate_no_prefs(dna)
    for i in range(int(len(no_pref_ids)/2)):
        swap_list.append((random.choice(no_pref_ids), random.choice(no_pref_ids)))
    dna = swap_ids(dna, swap_list)

    #this will swap some people who have mirror image preference
    swap_list = pref_swapper(dna, gen)
    dna = swap_ids(dna, swap_list)
    swap_list = []

    # still more to swap: these are ids that have advisor double bookings
    some_ids = advisee_doubles(dna)
    # print(some_ids)
    for n, i in enumerate(some_ids[:-1:2]):
        if some_ids[n*2+1]: swap_list.append(((i, some_ids[n*2+1])))

    dna = swap_ids(dna, swap_list)
    swap_list = []
    #print(swap_list)
    #for val in swap_list:
        #print(val)
     #   dna[val[0]], dna[val[1]] = dna[val[1]], dna[val[0]]

    # siblings for the swap list
    swap_list = sib_swaps(dna)
    dna = swap_ids(dna, swap_list)

    return dna


def pop_max_min(population):
    top = population[0][0]
    bottom = top
    max, min = 0, 0
    sum = 0
    for x, y in enumerate(population):
        sum += y[0]
        if y[0] > top:
            top = y[0]
            max = x
        if y[0] < bottom:
            bottom = y[0]
            min = x
    avg = sum / len(population)
    # top = highest fitness score
    # bottom = lowest fitness score
    # max = index of dna with highest fitness score
    return top, bottom, max, min, avg

def pick_parent(population): #roulette wheel style
    '''
    randomly pick a parent based on fitness score: higher the fitness score, more likely to be picked
    :param population:
    :return:
    '''
    pop_data = pop_max_min(population)
    min = pop_data[1]
    max = pop_data[0]
    x = min-1
    random_number = random.randint(min, max-1)
    while x < random_number:
        tmp = random.choice(population)
        x = tmp[0]
    #print(min,max,random_number, x)
    return tmp[1]

def pick_parent_tourney(population): # tournament style not as good as my roulette original
    '''
    randomly pick a parent based on fitness score: tournament style selection
    :param population:
    :return:
    '''
    pickA = random.choice(population)
    pickB = random.choice(population)
    if pickA[0] > pickB[0]:
        return pickA[1]
    else:
        return pickB[1]


def make_new_generation(population, pop_size,mutation_rate, gen = 1, preserve_top = 5):
    # pop_data = pop_max_min(population)
    # fittest = population[pop_data[2]]
    next_generation = []
    for i in range(pop_size):
        parent1 = pick_parent(population)
        parent2 = pick_parent(population)
        new_dna = crossover(parent1, parent2)
        if mutation_rate > 0: new_dna = mutate(new_dna, mutation_rate, gen = gen)
        next_generation.append([fitness(new_dna),new_dna])

    # This section would implement selecting best from BOTH gens to make new gen
    # Testing seems to indicate this is worse in the long run ... loses diverstity?
    #double = next_generation + population
    '''
    if preserve_top:
        population.sort(key= lambda x: x[0], reverse= True)
        next_generation = population[0:preserve_top] + next_generation[0:-preserve_top]
        next_generation.sort(key= lambda x: x[0], reverse= True)
        print([i[0] for i in next_generation[0:20]])
    '''
    # end COMBINATION optimization

    return next_generation

def get_over_books(dna):
    over_bookings = 0
    for slot, ids1 in get_time_slots(dna).items():
        for teacher, ids2 in teacher_classes.items():
            bookings = len(set(ids1).intersection(ids2))
            if bookings > 2:
                over_bookings +=1
    return over_bookings


def evaluate_dna(dna):
    '''
    return dictionary of data
    the_data=
    {'Fitness'
    'Students with First Choice':
    'Students with second choice or better'
    'Student with third choice or better'
    'Students who did NOT get ANY choices'
    'Non arts Triple Bookings'
    '
    }
    :param dna:
    :return:
    '''
    the_data = {}
    # the_data['Fitness:'] = fitness(dna)
    prefs = get_the_prefs_just_once
    pref1, pref2, pref3, no_pref = 0, 0, 0, 0
    for key, value in dna.items():
        if key not in get_the_prefs_just_once:
            continue
        pref = conftime_to_preftime(value)
        if pref in prefs[key][0]: # got first pref
            pref1 +=1
        elif pref in prefs[key][1]: # got second pref
            pref2 +=1
        elif pref in prefs[key][2]: # got third pref
            pref3 +=1
        else:
            no_pref +=1
    the_data['Got First Choice:'] = pref1
    the_data['Got Second Choice:'] = pref2
    the_data['Got Third Choice:'] = pref3
    the_data['Got None of their Choices:'] = no_pref
    the_data['Overbookings'] = get_over_books(dna)
    the_data['Advisee Double Bookings'] = len(advisee_doubles(dna))
    the_data['Siblings NOT back to Back'] = sib_score(dna)[1]
    return the_data

def save_best_schedule(dna, population_size, random_seed, mutation_rate = .07):
    #  mutation_rate, population_size, random_seed, date_produced datetime, schedule
    con = sqlite3.connect('conf.db')
    cur = con.cursor()
    sql = 'INSERT INTO schedules (score, mutation_rate, population_size, random_seed, date_produced , schedule) VALUES (?, ?, ?, ?, ?, ? )'
    cur.execute(sql,(fitness(dna), mutation_rate, population_size, random_seed, datetime.datetime.now(), json.dumps(dna)))
    con.commit()
    cur.close()
    con.close()

def export_confs(score = 0, style = 'csv'):
    con = sqlite3.connect('conf.db')
    table = sql.read_sql('select * from confs ORDER BY the_date, grade', con)

    table.to_csv('conf_output'+str(score)+'.csv')

    con.close()

def json_to_dict(dict):
    dna = {}
    for key, value in json.loads(dict).items():
        dna[int(key)] = value
    return dna

def get_schedule(scheduleID):
    # return the DNA of the schedule
    con = sqlite3.connect('conf.db')
    cur = con.cursor()
    sql = 'SELECT schedule FROM schedules WHERE scheduleID={};'.format(scheduleID)
    cur.execute(sql)
    rows = cur.fetchall()
    dna = json_to_dict(rows[0][0])
    return dna

def load_schedule(scheduleID):
    con = sqlite3.connect('conf.db')
    cur = con.cursor()
    sql = 'SELECT schedule FROM schedules WHERE scheduleID={};'.format(scheduleID)
    cur.execute(sql)
    rows = cur.fetchall()
    dna = json_to_dict(rows[0][0])
    # sets the time
    for id, slot in dna.items():
        sql = "UPDATE confs SET the_date='{}' WHERE studentID={};".format(slot, id)
        cur.execute(sql)
    #now set the room
    rooms = ['Daphne', 'PWS', 'RGS', 'Purdy' 'Athena', 'Poseiden']
    sql = 'SELECT * FROM confs ORDER BY the_date, grade DESC';
    cur.execute(sql)
    conf_time = ''
    rows = cur.fetchall()
    for i in rows:
        if i[2] != conf_time:
            rooms = ['Daphne', 'PWS', 'RGS', 'Purdy', 'Athena', 'Poseiden']
            conf_time = i[2]
        sql = "UPDATE confs SET room='{}' WHERE studentID={};".format(rooms.pop(),i[0])
        cur.execute(sql)

    con.commit()
    cur.close()
    con.close()


#print(fitness(get_schedule(132)))
#load_schedule(132)
#export_confs(1571)

#for key,value in evaluate_dna(get_schedule(132)).items():
#    print(key, value)
